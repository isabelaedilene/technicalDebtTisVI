file path,line #,comment,satd
PySnooper/setup.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/setup.py,2,This program is distributed under the MIT license.,
PySnooper/tests/test_pysnooper.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_pysnooper.py,2,This program is distributed under the MIT license.,
PySnooper/tests/test_pysnooper.py,311,doesn't have attributes,
PySnooper/tests/test_pysnooper.py,651,Multi-line decorator for extra confusion!,
PySnooper/tests/test_pysnooper.py,673,inside lambda,
PySnooper/tests/test_pysnooper.py,679,back in my_function,
PySnooper/tests/test_pysnooper.py,846,Testing that a single Tracer can handle many mixed uses,
PySnooper/tests/test_pysnooper.py,856,"There should be line entries for these three lines,",
PySnooper/tests/test_pysnooper.py,857,"no line entries for anything else in this function,",
PySnooper/tests/test_pysnooper.py,858,but calls to all bar functions should be traced,
PySnooper/tests/test_pysnooper.py,879,"not traced, mustn't show up",
PySnooper/tests/test_pysnooper.py,889,In first with,
PySnooper/tests/test_pysnooper.py,900,In with in recursive call,
PySnooper/tests/test_pysnooper.py,910,Call to bar1 from if block outside with,
PySnooper/tests/test_pysnooper.py,918,In with in recursive call,
PySnooper/tests/test_pysnooper.py,921,Call to bar2 from within with,
PySnooper/tests/test_pysnooper.py,929,In with in recursive call,
PySnooper/tests/test_pysnooper.py,932,Call to bar3 from after with,
PySnooper/tests/test_pysnooper.py,940,"-- Similar to previous few sections,",
PySnooper/tests/test_pysnooper.py,941,-- but from first call to foo,
PySnooper/tests/test_pysnooper.py,943,In with in first call,
PySnooper/tests/test_pysnooper.py,946,Call to bar2 from within with,
PySnooper/tests/test_pysnooper.py,954,In with in first call,
PySnooper/tests/test_pysnooper.py,957,Call to bar3 from after with,
PySnooper/tests/test_pysnooper.py,1211,Pause and resume:,
PySnooper/tests/test_pysnooper.py,1227,Pause and resume:,
PySnooper/tests/test_pysnooper.py,1512,"Do simple property operations, make sure we didn't mess up the normal behavior",
PySnooper/tests/test_pysnooper.py,1523,"The property methods will not be traced, but their calls to plain_method will be.",
PySnooper/tests/test_pysnooper.py,1535,Called from getter,
PySnooper/tests/test_pysnooper.py,1542,Called from setter,
PySnooper/tests/test_pysnooper.py,1549,Called from deleter,
PySnooper/tests/test_not_implemented.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_not_implemented.py,2,This program is distributed under the MIT license.,
PySnooper/tests/utils.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/utils.py,2,This program is distributed under the MIT license.,
PySnooper/tests/utils.py,347,to copy paste into expected_output,
PySnooper/tests/utils.py,348,show pytest diff (may need -vv flag to see in full),
PySnooper/tests/test_chinese.py,1,-*- coding: utf-8 -*-,
PySnooper/tests/test_chinese.py,2,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_chinese.py,3,This program is distributed under the MIT license.,
PySnooper/tests/test_multiple_files/test_multiple_files.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_multiple_files/test_multiple_files.py,2,This program is distributed under the MIT license.,
PySnooper/tests/test_multiple_files/multiple_files/bar.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_multiple_files/multiple_files/bar.py,2,This program is distributed under the MIT license.,
PySnooper/tests/test_multiple_files/multiple_files/foo.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_multiple_files/multiple_files/foo.py,2,This program is distributed under the MIT license.,
PySnooper/tests/mini_toolbox/contextlib.py,11,Backwards compatibility,
PySnooper/tests/mini_toolbox/contextlib.py,60,Issue 19330: ensure context manager instances have good docstrings,
PySnooper/tests/mini_toolbox/contextlib.py,65,"Unfortunately, this still doesn't provide good help output when",
PySnooper/tests/mini_toolbox/contextlib.py,66,"inspecting the created context manager instances, since pydoc",
PySnooper/tests/mini_toolbox/contextlib.py,67,currently bypasses the instance docstring and shows the docstring,
PySnooper/tests/mini_toolbox/contextlib.py,68,for the class instead.,
PySnooper/tests/mini_toolbox/contextlib.py,69,See http://bugs.python.org/issue19404 for more details.,
PySnooper/tests/mini_toolbox/contextlib.py,72,"_GCM instances are one-shot context managers, so the",
PySnooper/tests/mini_toolbox/contextlib.py,73,CM must be recreated each time a decorated function is,
PySnooper/tests/mini_toolbox/contextlib.py,74,called,
PySnooper/tests/mini_toolbox/contextlib.py,93,Need to force instantiation so we can reliably,
PySnooper/tests/mini_toolbox/contextlib.py,94,tell if we get the same exception back,
PySnooper/tests/mini_toolbox/contextlib.py,100,Suppress StopIteration *unless* it's the same exception that,
PySnooper/tests/mini_toolbox/contextlib.py,101,was passed to throw().  This prevents a StopIteration,
PySnooper/tests/mini_toolbox/contextlib.py,102,"raised inside the ""with"" statement from being suppressed.",
PySnooper/tests/mini_toolbox/contextlib.py,105,Don't re-raise the passed in exception,
PySnooper/tests/mini_toolbox/contextlib.py,108,"Likewise, avoid suppressing if a StopIteration exception",
PySnooper/tests/mini_toolbox/contextlib.py,109,was passed to throw() and later wrapped into a RuntimeError,
PySnooper/tests/mini_toolbox/contextlib.py,110,(see PEP 479).,
PySnooper/tests/mini_toolbox/contextlib.py,115,only re-raise if it's *not* the exception that was,
PySnooper/tests/mini_toolbox/contextlib.py,116,"passed to throw(), because __exit__() must not raise",
PySnooper/tests/mini_toolbox/contextlib.py,117,an exception unless __exit__() itself failed.  But throw(),
PySnooper/tests/mini_toolbox/contextlib.py,118,"has to raise the exception to signal propagation, so this",
PySnooper/tests/mini_toolbox/contextlib.py,119,fixes the impedance mismatch between the throw() protocol,
PySnooper/tests/mini_toolbox/contextlib.py,120,and the __exit__() protocol.,
PySnooper/tests/mini_toolbox/contextlib.py,121,,
PySnooper/tests/mini_toolbox/contextlib.py,191,We use a list of old targets to make this CM re-entrant,
PySnooper/tests/mini_toolbox/contextlib.py,243,"Unlike isinstance and issubclass, CPython exception handling",
PySnooper/tests/mini_toolbox/contextlib.py,244,currently only looks at the concrete type hierarchy (ignoring,
PySnooper/tests/mini_toolbox/contextlib.py,245,the instance and subclass checking hooks). While Guido considers,
PySnooper/tests/mini_toolbox/contextlib.py,246,"that a bug rather than a feature, it's a fairly hard one to fix",
PySnooper/tests/mini_toolbox/contextlib.py,247,due to various internal implementation details. suppress provides,
PySnooper/tests/mini_toolbox/contextlib.py,248,"the simpler issubclass based semantics, rather than trying to",
PySnooper/tests/mini_toolbox/contextlib.py,249,exactly reproduce the limitations of the CPython interpreter.,
PySnooper/tests/mini_toolbox/contextlib.py,250,,
PySnooper/tests/mini_toolbox/contextlib.py,251,See http://bugs.python.org/issue12029 for more details,
PySnooper/tests/mini_toolbox/contextlib.py,255,Context manipulation is Python 3 only,
PySnooper/tests/mini_toolbox/contextlib.py,260,"Context may not be correct, so find the end of the chain",
PySnooper/tests/mini_toolbox/contextlib.py,264,Context is already set correctly (see issue 20317),
PySnooper/tests/mini_toolbox/contextlib.py,269,Change the end of the chain to point to the exception,
PySnooper/tests/mini_toolbox/contextlib.py,270,we expect it to reference,
PySnooper/tests/mini_toolbox/contextlib.py,276,"bare ""raise exc_details[1]"" replaces our carefully",
PySnooper/tests/mini_toolbox/contextlib.py,277,set-up context,
PySnooper/tests/mini_toolbox/contextlib.py,284,No exception context in Python 2,
PySnooper/tests/mini_toolbox/contextlib.py,288,"Use 3 argument raise in Python 2,",
PySnooper/tests/mini_toolbox/contextlib.py,289,but use exec to avoid SyntaxError in Python 3,
PySnooper/tests/mini_toolbox/contextlib.py,294,Handle old-style classes if they exist,
PySnooper/tests/mini_toolbox/contextlib.py,298,Python 3 doesn't have old-style classes,
PySnooper/tests/mini_toolbox/contextlib.py,301,Need to handle old-style context managers on Python 2,
PySnooper/tests/mini_toolbox/contextlib.py,305,Old-style class,
PySnooper/tests/mini_toolbox/contextlib.py,306,New-style class,
PySnooper/tests/mini_toolbox/contextlib.py,308,Inspired by discussions on http://bugs.python.org/issue13585,
PySnooper/tests/mini_toolbox/contextlib.py,346,We use an unbound method rather than a bound method to follow,
PySnooper/tests/mini_toolbox/contextlib.py,347,the standard lookup behaviour for special methods,
PySnooper/tests/mini_toolbox/contextlib.py,352,"Not a context manager, so assume its a callable",
PySnooper/tests/mini_toolbox/contextlib.py,356,Allow use as a decorator,
PySnooper/tests/mini_toolbox/contextlib.py,365,"We changed the signature, so using @wraps is not appropriate, but",
PySnooper/tests/mini_toolbox/contextlib.py,366,setting __wrapped__ may still help with introspection,
PySnooper/tests/mini_toolbox/contextlib.py,369,Allow use as a decorator,
PySnooper/tests/mini_toolbox/contextlib.py,377,We look up the special methods on the type to match the with statement,
PySnooper/tests/mini_toolbox/contextlib.py,394,We manipulate the exception state so it behaves as though,
PySnooper/tests/mini_toolbox/contextlib.py,395,we were actually nesting multiple with statements,
PySnooper/tests/mini_toolbox/contextlib.py,399,Callbacks are invoked in LIFO order to match the behaviour of,
PySnooper/tests/mini_toolbox/contextlib.py,400,nested context managers,
PySnooper/tests/mini_toolbox/contextlib.py,412,simulate the stack of exceptions by setting the context,
PySnooper/tests/mini_toolbox/contextlib.py,420,Preserve backwards compatibility,
PySnooper/tests/mini_toolbox/__init__.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/mini_toolbox/__init__.py,2,This program is distributed under the MIT license.,
PySnooper/tests/mini_toolbox/__init__.py,83,,
PySnooper/tests/mini_toolbox/__init__.py,84,"We let the user input either an `(object, attribute_string)`, a",
PySnooper/tests/mini_toolbox/__init__.py,85,"`(dict, key)` pair, or a `(getter, setter)` pair. So now it's our job",
PySnooper/tests/mini_toolbox/__init__.py,86,to inspect `variable` and figure out which one of these options the,
PySnooper/tests/mini_toolbox/__init__.py,87,"user chose, and then obtain from that a `(getter, setter)` pair that",
PySnooper/tests/mini_toolbox/__init__.py,88,we could use.,
PySnooper/tests/mini_toolbox/__init__.py,101,"`first` is a dictoid; so we were probably handed a `(dict, key)`",
PySnooper/tests/mini_toolbox/__init__.py,102,pair.,
PySnooper/tests/mini_toolbox/__init__.py,107,"Finished handling the `(dict, key)` case.",
PySnooper/tests/mini_toolbox/__init__.py,110,"`second` is a callable; so we were probably handed a `(getter,",
PySnooper/tests/mini_toolbox/__init__.py,111,setter)` pair.,
PySnooper/tests/mini_toolbox/__init__.py,115,"Finished handling the `(getter, setter)` case.",
PySnooper/tests/mini_toolbox/__init__.py,117,"All that's left is the `(object, attribute_string)` case.",
PySnooper/tests/mini_toolbox/__init__.py,124,"Finished handling the `(object, attribute_string)` case.",
PySnooper/tests/mini_toolbox/__init__.py,126,,
PySnooper/tests/mini_toolbox/__init__.py,127,,
PySnooper/tests/mini_toolbox/__init__.py,128,"Finished obtaining a `(getter, setter)` pair from `variable`.",
PySnooper/tests/mini_toolbox/__init__.py,152,In `__exit__` we'll want to check if anyone changed the value of the,
PySnooper/tests/mini_toolbox/__init__.py,153,"variable in the suite, which is unallowed. But we can't compare to",
PySnooper/tests/mini_toolbox/__init__.py,154,"`.value`, because sometimes when you set a value to a variable, some",
PySnooper/tests/mini_toolbox/__init__.py,155,"mechanism modifies that value for various reasons, resulting in a",
PySnooper/tests/mini_toolbox/__init__.py,156,"supposedly equivalent, but not identical, value. For example this",
PySnooper/tests/mini_toolbox/__init__.py,157,happens when you set the current working directory on Mac OS.,
PySnooper/tests/mini_toolbox/__init__.py,158,,
PySnooper/tests/mini_toolbox/__init__.py,159,"So here we record the value right after setting, and after any",
PySnooper/tests/mini_toolbox/__init__.py,160,possible processing the system did to it:,
PySnooper/tests/mini_toolbox/__init__.py,169,Asserting no-one inside the suite changed our variable:,
PySnooper/tests/mini_toolbox/__init__.py,197,not stdout,
PySnooper/tests/mini_toolbox/__init__.py,203,not stderr,
PySnooper/tests/mini_toolbox/__init__.py,213,Not doing exception swallowing anywhere here.,
PySnooper/tests/mini_toolbox/__init__.py,250,We don't allow anyone to remove it except for us:,
PySnooper/tests/mini_toolbox/pathlib.py,1,Copyright (c) 2014-2017 Matthias C. M. Troffaes,
PySnooper/tests/mini_toolbox/pathlib.py,2,Copyright (c) 2012-2014 Antoine Pitrou and contributors,
PySnooper/tests/mini_toolbox/pathlib.py,3,Distributed under the terms of the MIT License.,
PySnooper/tests/mini_toolbox/pathlib.py,56,,
PySnooper/tests/mini_toolbox/pathlib.py,57,Internals,
PySnooper/tests/mini_toolbox/pathlib.py,58,,
PySnooper/tests/mini_toolbox/pathlib.py,62,py2 => minimal unicode support,
PySnooper/tests/mini_toolbox/pathlib.py,127,"get file information, needed for samefile on older Python versions",
PySnooper/tests/mini_toolbox/pathlib.py,128,see http://timgolden.me.uk/python/win32_how_do_i/,
PySnooper/tests/mini_toolbox/pathlib.py,129,see_if_two_files_are_the_same_file.html,
PySnooper/tests/mini_toolbox/pathlib.py,189,"Whether this pattern needs actual matching using fnmatch, or can",
PySnooper/tests/mini_toolbox/pathlib.py,190,be looked up directly as a file.,
PySnooper/tests/mini_toolbox/pathlib.py,225,"If no drive is present, try to find one in the previous",
PySnooper/tests/mini_toolbox/pathlib.py,226,parts. This makes the result of parsing e.g.,
PySnooper/tests/mini_toolbox/pathlib.py,227,"(""C:"", ""/"", ""a"") reasonably intuitive.",
PySnooper/tests/mini_toolbox/pathlib.py,252,Same drive => second path is relative to the first,
PySnooper/tests/mini_toolbox/pathlib.py,255,Second path is non-anchored (common case),
PySnooper/tests/mini_toolbox/pathlib.py,261,Reference for Windows paths can be found at,
PySnooper/tests/mini_toolbox/pathlib.py,262,http://msdn.microsoft.com/en-us/library/aa365247%28v=vs.85%29.aspx,
PySnooper/tests/mini_toolbox/pathlib.py,280,Interesting findings about extended paths:,
PySnooper/tests/mini_toolbox/pathlib.py,281,"- '\\?\c:\a', '//?/c:\a' and '//?/c:/a' are all supported",
PySnooper/tests/mini_toolbox/pathlib.py,282,but '\\?\c:/a' is not,
PySnooper/tests/mini_toolbox/pathlib.py,283,"- extended paths are always absolute; ""relative"" extended paths will",
PySnooper/tests/mini_toolbox/pathlib.py,284,fail.,
PySnooper/tests/mini_toolbox/pathlib.py,290,"XXX extended paths should also disable the collapsing of "".""",
PySnooper/tests/mini_toolbox/pathlib.py,291,components (according to MSDN docs).,
PySnooper/tests/mini_toolbox/pathlib.py,299,is a UNC path:,
PySnooper/tests/mini_toolbox/pathlib.py,300,vvvvvvvvvvvvvvvvvvvvv root,
PySnooper/tests/mini_toolbox/pathlib.py,301,\\machine\mountpoint\directory\etc\...,
PySnooper/tests/mini_toolbox/pathlib.py,302,directory ^^^^^^^^^^^^^^,
PySnooper/tests/mini_toolbox/pathlib.py,306,a UNC path can't have two slashes in a row,
PySnooper/tests/mini_toolbox/pathlib.py,307,(after the initial two),
PySnooper/tests/mini_toolbox/pathlib.py,340,End of the path after the first one not found,
PySnooper/tests/mini_toolbox/pathlib.py,353,Means fallback on absolute,
PySnooper/tests/mini_toolbox/pathlib.py,367,Turn back an extended path into a normal DOS-like path,
PySnooper/tests/mini_toolbox/pathlib.py,371,NOTE: the rules for reserved names seem somewhat complicated,
PySnooper/tests/mini_toolbox/pathlib.py,372,"(e.g. r""..\NUL"" is reserved but not r""foo\NUL"").",
PySnooper/tests/mini_toolbox/pathlib.py,373,We err on the side of caution and return True for paths which are,
PySnooper/tests/mini_toolbox/pathlib.py,374,not considered reserved by Windows.,
PySnooper/tests/mini_toolbox/pathlib.py,378,UNC paths are never reserved,
PySnooper/tests/mini_toolbox/pathlib.py,383,"Under Windows, file URIs use the UTF-8 encoding.",
PySnooper/tests/mini_toolbox/pathlib.py,386,It's a path on a local drive => 'file:///c:/a/b',
PySnooper/tests/mini_toolbox/pathlib.py,391,It's a path on a network drive => 'file://host/share/a/b',
PySnooper/tests/mini_toolbox/pathlib.py,410,Try to guess user home directory.  By default all users,
PySnooper/tests/mini_toolbox/pathlib.py,411,directories are located in the same place and are named by,
PySnooper/tests/mini_toolbox/pathlib.py,412,corresponding usernames.  If current user home directory points,
PySnooper/tests/mini_toolbox/pathlib.py,413,"to nonstandard place, this guess is likely wrong.",
PySnooper/tests/mini_toolbox/pathlib.py,438,According to POSIX path resolution:,
PySnooper/tests/mini_toolbox/pathlib.py,439,http://pubs.opengroup.org/onlinepubs/009695399/basedefs/,
PySnooper/tests/mini_toolbox/pathlib.py,440,xbd_chap04.html#tag_04_11,
PySnooper/tests/mini_toolbox/pathlib.py,441,"""A pathname that begins with two successive slashes may be",
PySnooper/tests/mini_toolbox/pathlib.py,442,"interpreted in an implementation-defined manner, although more",
PySnooper/tests/mini_toolbox/pathlib.py,443,"than two leading slashes shall be treated as a single slash"".",
PySnooper/tests/mini_toolbox/pathlib.py,468,current dir,
PySnooper/tests/mini_toolbox/pathlib.py,471,parent dir,
PySnooper/tests/mini_toolbox/pathlib.py,476,Already seen this path,
PySnooper/tests/mini_toolbox/pathlib.py,479,use cached value,
PySnooper/tests/mini_toolbox/pathlib.py,481,"The symlink is not resolved, so we must have a symlink",
PySnooper/tests/mini_toolbox/pathlib.py,482,loop.,
PySnooper/tests/mini_toolbox/pathlib.py,484,Resolve the symbolic link,
PySnooper/tests/mini_toolbox/pathlib.py,490,"Not a symlink, or non-strict mode. We just leave the path",
PySnooper/tests/mini_toolbox/pathlib.py,491,untouched.,
PySnooper/tests/mini_toolbox/pathlib.py,494,not resolved symlink,
PySnooper/tests/mini_toolbox/pathlib.py,496,resolved symlink,
PySnooper/tests/mini_toolbox/pathlib.py,499,"NOTE: according to POSIX, getcwd() cannot contain path components",
PySnooper/tests/mini_toolbox/pathlib.py,500,which are symlinks.,
PySnooper/tests/mini_toolbox/pathlib.py,508,"We represent the path using the local filesystem encoding,",
PySnooper/tests/mini_toolbox/pathlib.py,509,for portability to other applications.,
PySnooper/tests/mini_toolbox/pathlib.py,590,"Under POSIX, os.symlink() takes two args",
PySnooper/tests/mini_toolbox/pathlib.py,597,Helper for resolve(),
PySnooper/tests/mini_toolbox/pathlib.py,605,,
PySnooper/tests/mini_toolbox/pathlib.py,606,Globbing helpers,
PySnooper/tests/mini_toolbox/pathlib.py,607,,
PySnooper/tests/mini_toolbox/pathlib.py,756,,
PySnooper/tests/mini_toolbox/pathlib.py,757,Public API,
PySnooper/tests/mini_toolbox/pathlib.py,758,,
PySnooper/tests/mini_toolbox/pathlib.py,767,We don't store the instance to avoid reference cycles,
PySnooper/tests/mini_toolbox/pathlib.py,813,Using the parts tuple helps share interned path parts,
PySnooper/tests/mini_toolbox/pathlib.py,814,when pickling related paths.,
PySnooper/tests/mini_toolbox/pathlib.py,819,"This is useful when you don't want to create an instance, just",
PySnooper/tests/mini_toolbox/pathlib.py,820,canonicalize some constructor arguments.,
PySnooper/tests/mini_toolbox/pathlib.py,829,duck typing for older Python versions,
PySnooper/tests/mini_toolbox/pathlib.py,833,Force-cast str subclasses to str (issue #21127),
PySnooper/tests/mini_toolbox/pathlib.py,835,also handle unicode for PY2 (six.text_type = unicode),
PySnooper/tests/mini_toolbox/pathlib.py,837,cast to str using filesystem encoding,
PySnooper/tests/mini_toolbox/pathlib.py,848,"We need to call _parse_args on the instance, so as to get the",
PySnooper/tests/mini_toolbox/pathlib.py,849,right flavour.,
PySnooper/tests/mini_toolbox/pathlib.py,877,Overridden in concrete Path,
PySnooper/tests/mini_toolbox/pathlib.py,923,"Cached casefolded parts, for hashing and comparison",
PySnooper/tests/mini_toolbox/pathlib.py,1035,"XXX if suffix is None, should the current suffix be removed?",
PySnooper/tests/mini_toolbox/pathlib.py,1057,"For the purpose of this method, drive and root are considered",
PySnooper/tests/mini_toolbox/pathlib.py,1058,"separate parts, i.e.:",
PySnooper/tests/mini_toolbox/pathlib.py,1059,Path('c:/').relative_to('c:')  gives Path('/'),
PySnooper/tests/mini_toolbox/pathlib.py,1060,Path('c:/').relative_to('/')   raise ValueError,
PySnooper/tests/mini_toolbox/pathlib.py,1088,We cache the tuple to avoid building a new one each time .parts,
PySnooper/tests/mini_toolbox/pathlib.py,1089,is accessed.  XXX is this necessary?,
PySnooper/tests/mini_toolbox/pathlib.py,1167,Can't subclass os.PathLike from PurePath and keep the constructor,
PySnooper/tests/mini_toolbox/pathlib.py,1168,optimizations in PurePath._parse_args().,
PySnooper/tests/mini_toolbox/pathlib.py,1183,Filesystem-accessing classes,
PySnooper/tests/mini_toolbox/pathlib.py,1203,Private non-constructor arguments,
PySnooper/tests/mini_toolbox/pathlib.py,1213,This is an optimization used for dir walking.  `part` must be,
PySnooper/tests/mini_toolbox/pathlib.py,1214,a single part relative to this path.,
PySnooper/tests/mini_toolbox/pathlib.py,1230,A stub for the opener argument to built-in open(),
PySnooper/tests/mini_toolbox/pathlib.py,1242,Public API,
PySnooper/tests/mini_toolbox/pathlib.py,1284,Yielding a path object for these makes little sense,
PySnooper/tests/mini_toolbox/pathlib.py,1323,XXX untested yet!,
PySnooper/tests/mini_toolbox/pathlib.py,1328,"FIXME this must defer to the specific flavour (and, under Windows,",
PySnooper/tests/mini_toolbox/pathlib.py,1329,use nt._getfullpathname()),
PySnooper/tests/mini_toolbox/pathlib.py,1344,"No symlink resolution => for consistency, raise an error if",
PySnooper/tests/mini_toolbox/pathlib.py,1345,the path doesn't exist or is forbidden,
PySnooper/tests/mini_toolbox/pathlib.py,1348,"Now we have no symlinks in the path, it's safe to normalize it.",
PySnooper/tests/mini_toolbox/pathlib.py,1434,First try to bump modification time,
PySnooper/tests/mini_toolbox/pathlib.py,1435,Implementation note: GNU touch uses the UTIME_NOW option of,
PySnooper/tests/mini_toolbox/pathlib.py,1436,the utimensat() / futimens() functions.,
PySnooper/tests/mini_toolbox/pathlib.py,1440,Avoid exception chaining,
PySnooper/tests/mini_toolbox/pathlib.py,1545,Convenience functions for querying the stat results,
PySnooper/tests/mini_toolbox/pathlib.py,1568,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1569,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/mini_toolbox/pathlib.py,1582,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1583,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/mini_toolbox/pathlib.py,1595,Path doesn't exist,
PySnooper/tests/mini_toolbox/pathlib.py,1607,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1608,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/mini_toolbox/pathlib.py,1620,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1621,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/mini_toolbox/pathlib.py,1633,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1634,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/mini_toolbox/pathlib.py,1646,Path doesn't exist or is a broken symlink,
PySnooper/tests/mini_toolbox/pathlib.py,1647,(see https://bitbucket.org/pitrou/pathlib/issue/12/),
PySnooper/tests/test_utils/test_ensure_tuple.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/tests/test_utils/test_ensure_tuple.py,2,This program is distributed under the MIT license.,
PySnooper/misc/generate_authors.py,1,!/usr/bin/env python,
PySnooper/misc/generate_authors.py,2,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/misc/generate_authors.py,3,This program is distributed under the MIT license.,
PySnooper/pysnooper/utils.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/pysnooper/utils.py,2,This program is distributed under the MIT license.,
PySnooper/pysnooper/utils.py,39,IronPython weirdness.,
PySnooper/pysnooper/tracer.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/pysnooper/tracer.py,2,This program is distributed under the MIT license.,
PySnooper/pysnooper/tracer.py,87,We used to check `if source is None` but I found a rare bug where it,
PySnooper/pysnooper/tracer.py,88,"was empty, but not `None`, so now we check `if not source`.",
PySnooper/pysnooper/tracer.py,91,"If we just read the source from a file, or if the loader did not",
PySnooper/pysnooper/tracer.py,92,apply tokenize.detect_encoding to decode the source into a,
PySnooper/pysnooper/tracer.py,93,"string, then we should do that ourselves.",
PySnooper/pysnooper/tracer.py,97,File coding may be specified. Match pattern from PEP-263,
PySnooper/pysnooper/tracer.py,98,(https://www.python.org/dev/peps/pep-0263/),
PySnooper/pysnooper/tracer.py,122,God damn Python 2,
PySnooper/pysnooper/tracer.py,242,"Coroutines are functions, but snooping them is not supported",
PySnooper/pysnooper/tracer.py,243,at the moment,
PySnooper/pysnooper/tracer.py,321,Checking whether we should trace this line:,
PySnooper/pysnooper/tracer.py,322,,
PySnooper/pysnooper/tracer.py,323,"We should trace this line either if it's in the decorated function,",
PySnooper/pysnooper/tracer.py,324,or the user asked to go a few levels deeper and we're within that,
PySnooper/pysnooper/tracer.py,325,number of levels deeper.,
PySnooper/pysnooper/tracer.py,329,"We did the most common and quickest check above, because the",
PySnooper/pysnooper/tracer.py,330,"trace function runs so incredibly often, therefore it's",
PySnooper/pysnooper/tracer.py,331,crucial to hyper-optimize it for the common case.,
PySnooper/pysnooper/tracer.py,351,,
PySnooper/pysnooper/tracer.py,352,Finished checking whether we should trace this line.,
PySnooper/pysnooper/tracer.py,374,Reporting newish and modified variables:,
PySnooper/pysnooper/tracer.py,375,,
PySnooper/pysnooper/tracer.py,395,,
PySnooper/pysnooper/tracer.py,396,Finished newish and modified variables.,
PySnooper/pysnooper/tracer.py,399,Dealing with misplaced function definition:,
PySnooper/pysnooper/tracer.py,400,,
PySnooper/pysnooper/tracer.py,402,"If a function decorator is found, skip lines until an actual",
PySnooper/pysnooper/tracer.py,403,function definition is found.,
PySnooper/pysnooper/tracer.py,408,End of source file reached without finding a function,
PySnooper/pysnooper/tracer.py,409,definition. Fall back to original source line.,
PySnooper/pysnooper/tracer.py,413,Found the def line!,
PySnooper/pysnooper/tracer.py,417,,
PySnooper/pysnooper/tracer.py,418,Finished dealing with misplaced function definition.,
PySnooper/pysnooper/tracer.py,420,"If a call ends due to an exception, we still get a 'return' event",
PySnooper/pysnooper/tracer.py,421,with arg = None. This seems to be the only way to tell the difference,
PySnooper/pysnooper/tracer.py,422,https://stackoverflow.com/a/12800909/2482744,
PySnooper/pysnooper/__init__.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/pysnooper/__init__.py,2,This program is distributed under the MIT license.,
PySnooper/pysnooper/__init__.py,30,Avoid polluting the namespace,
PySnooper/pysnooper/pycompat.py,1,Copyright 2019 Ram Rachum and collaborators.,
PySnooper/pysnooper/pycompat.py,2,This program is distributed under the MIT license.,
PySnooper/pysnooper/pycompat.py,40,Make a concession for older `pathlib` versions:g,
PySnooper/pysnooper/pycompat.py,49,Lolz,
PySnooper/pysnooper/pycompat.py,54,Lolz,
PySnooper/pysnooper/pycompat.py,66,Python 2.7,
